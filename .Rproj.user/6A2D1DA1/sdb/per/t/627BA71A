{
    "contents" : "genalg <-function(formula, data, family=gaussian(), population=200, generations=100, mutateRate=0.02, elitism=NA, zeroOneRatio=10, verbose=TRUE, fun.eval=evalAICc) {\n    # Get the exponential family of the response\n    if(is.character(family))\n        family <- get(family, mode = \"function\", envir = parent.frame())\n    if(is.function(family)) family <- family()\n    if(is.null(family$family)) {\n        print(family)\n        stop(\"'family' not recognized\")\n    }\n    \n    # Match the variables that are referenced in the function call\n    mf = match.call(expand.dots=FALSE)\n    m <- match(c(\"formula\", \"data\", \"weights\", \"na.action\"), names(mf), 0)\n    mf <- mf[c(1, m)]\n    \n    # We need to evaluate the function call in the next environment up because we've added a level of abstraction with this function.\n    mf[[1]] <- as.name(\"model.frame\")\n    mf <- eval(mf)\n    mt <- attr(mf, \"terms\")\n    \n    # Get the data and the weights\n    y <- model.response(mf, \"numeric\")\n    x <- model.matrix(mt, mf, contrasts)\n    w <- model.weights(mf)\n    \n    #Figure out whether there's an intercept, and which columns of x are dummy variables for factors:\n    intercept = ifelse(attr(mt, \"intercept\")==0, FALSE, TRUE)\n    var.id = attr(x, \"assign\")\n    \n    # Check for problems with the (prior) weights\n    if (!is.null(w) && !is.numeric(w)) \n        stop(\"'weights' must be a numeric vector\")\n    if (is.null(w)) \n        w <- rep(1, nrow(data))\n    if (any(is.na(w))) \n        stop(\"NAs in weights\")\n    if (any(w < 0)) \n        stop(\"negative weights\")\n    \n    #Create the object that will hold the output\n    result = list()\n    \n    #Drop any rows with NA values\n    na.rows = (which(is.na(data))-1) %% dim(data)[1] + 1\n    if (length(na.rows)>0)\n        data = data[-na.rows,]\n        \n    p = ncol(data)\n    n = nrow(data)\n    \n    #Maximum number of predictor variables:\n    result[['ga']] = rbga.bin(x, y, w, intercept, family, zeroToOneRatio=zeroOneRatio, evalFunc=fun.eval, monitorFunc=monitor, mutationChance=mutateRate, n.pop=population, n.iter=generations, verbose=verbose)\n    \n    indx = which.min(result[['ga']]$evaluations)\n    indiv = as.logical(drop(result[[\"ga\"]]$population[indx,]))\n    \n    #Assemble the design matrix for the highest-fitness model:\n    cols = which(var.id %in% which(indiv==1))\n    x.final = x[,cols]\n    if (intercept) {x.final = cbind(1, x.final)}\n    \n    result[['vars']] = attr(mf, \"term.labels\")[which(indiv==1)]\n    #result[['formula']] = as.formula(paste(response.name, \"~\", paste(result[['vars']], collapse=\"+\"), sep=\"\"))\n    result[[\"model\"]] = glm.fit(y=y, x=x.final, weights=w, family=family)\n    \n    result[['fitted']] = fitted(result[['model']])\n    result[['residuals']] = residuals(result[['model']])\n    result[['actual']] = result[['fitted']] + result[['residuals']]\n    \n    class(result) = \"genalg\"\n    \n    result\n}\n",
    "created" : 1408556561053.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2315005427",
    "id" : "627BA71A",
    "lastKnownWriteTime" : 1408570117,
    "path" : "C:/Users/wrbrooks/git/genetic/R/genalg.R",
    "project_path" : "R/genalg.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}